# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она работала слишком долго, и не было понятно, закончит ли она вообще работу за какое-то разумное время.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я решила использовать такую метрику: Количество памяти, которое потребляет программа при обработке файла.

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за секунды.

Вот как я построил `feedback_loop`:
- формирую отчет профайлера
- нахожу точку роста
- вношу правки в код
- формирую новый отчет
- фиксирую полученный результат

## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался stackprof, ruby-prof, memory-profiler

Вот какие проблемы удалось найти и решить

### Находка №0
- Файл data_large.txt обработать не удалось, для дальнейшей работы на его основе был сформирован вайл в 20 тыс. строк.
Обработка сформированного файла исходным кодом заняла:
`MEMORY USAGE: 129 MB`
- Перепишем работу программы в потоковом режиме.
Теперь запись в файл происходит постепенно, по мере чтения data_small.txt, когда очередная строка начинается со слова 'user' записываем данные сессий предыдущего пользователя в result.json.
- для файла в 20_000 строк.
```
MEMORY USAGE: 102 MB
Total allocated: 57.52 MB (386492 objects)
Total retained:  7.32 kB (64 objects)
```

Из интереса взяла программу полученную в предыдущем задании, получила такой же результат по памяти. `MEMORY USAGE: 129 MB`

### Находка №1
- memory_profiler показал мнрого памяти занимает класс
```
allocated memory by class
  25.74 MB  File
```
Это связано с тем, что каждый раз для записи я использовала File.write, получается он каждый раз при вызове открывался и закрывался, и видимо какая-то часть данных оставалась и не зачищалась
- `25.74 MB  File` -> `25.32 kB  File`
- как изменился отчёт профилировщика
до:
```
MEMORY USAGE: 102 MB
Total allocated: 57.52 MB (386492 objects)
Total retained:  7.32 kB (64 objects)
```
после:
```
MEMORY USAGE: 97 MB
Total allocated: 29.80 MB (365162 objects)
Total retained:  7.32 kB (64 objects)
```

### Находка №2
- в результате профилирования memory_profiler, выделю в качестве точки роста String
```
allocated memory by class
18.05 MB  String
allocated objects by class
285967  String
```
- добавила магический комментарий `# frozen_string_literal: true` и bang! - методы для строк
- как изменился отчёт профилировщика
до```
MEMORY USAGE: 97 MB
Total allocated: 29.80 MB (365162 objects)
Total retained:  7.32 kB (64 objects)
```
после ```
MEMORY USAGE: 82 MB
Total allocated: 24.84 MB (265428 objects)
Total retained:  7.32 kB (64 objects)
```
-
```
                            before            after
allocated memory by class   18.05 MB  String  13.33 MB  String
allocated objects by class  285967  String    192189  String
```

### Находка №3
- memory_profiler так же String
- убрала сохранение не используемых данных при парсинге сессий, при записи сессий убрала частый вызов map, сделала сбор браузеров, времени и дат внутри блока sessions.each
- как изменилась метрика
до
```
MEMORY USAGE:     82 MB
Total allocated:  24.84 MB (265428 objects)
Total retained:   7.32 kB (64 objects)
```
после
```
MEMORY USAGE: 78 MB
Total allocated: 24.62 MB (248474 objects)
Total retained:  7.32 kB (64 objects)
```
- как изменился отчёт профилировщика
```
                            before            after
allocated memory by class   13.33 MB  String  12.48 MB  String
allocated objects by class  192189  String    175235  String
```

так же проверила доработанный код на файле размером в 40_000 строк
```
Total allocated: 49.15 MB (496160 objects)
Total retained:  7.32 kB (64 objects)
```

## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы и уложиться в заданный бюджет.

```
# для файла размером 20_000 строк
                  before                    after
Total allocated:  1.70 GB (933874 objects)  24.61 MB (248450 objects)
Total retained:   4.27 kB (10 objects)      7.32 kB (64 objects)
```

Интересно, что в результате оптимизации при обработке файла разных размеров объем используемой памяти не изменяется
```
"18 строк"
Start work
MEMORY USAGE: 26 MB
"20_000 строк"
Start work
MEMORY USAGE: 27 MB
"40_000 строк"
Start work
MEMORY USAGE: 27 MB
"data_large.txt"
Start work
MEMORY USAGE: 27 MB
```

## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы были добавлены performance тесты на время исполнения программы
