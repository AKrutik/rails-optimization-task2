### Note
*Для работы скрипта требуется Ruby 2.4+*

# Задание №2
В этом задании нужно сделать дальнейшие оптимизации программы, с которой вы познакомились в задании №1.

На этот раз нужно оптимизировать её по памяти.

**Бюджет**: программа не должна потреблять больше 75Мб памяти в течение своей работы.

## Как измерять кол-во использованной памяти
В фидбек-лупе можно получать кол-во памяти *в конце* выполнения программы:

```ruby
puts "MEMORY USAGE: %d MB" % (`ps -o rss= -p #{Process.pid}`.to_i / 1024)"
```

После успешной оптимизации дополнительно нужно профилировать программу с помощью `valgrind massif visualizer` и проверить, что память укладывается в бюджет не только в конце работы программы, но и в течение вообще всего времени работы.

## Задача
- Оптимизировать эту программу, выстроив процесс согласно "общему фреймворку оптимизации" из первой лекции;
- Профилировать программу с помощью инструментов, с которыми мы познакомились во второй лекции;
- Добиться того, чтобы программа корректно обработала файл `data_large.txt` с потреблением памяти `< 70Mb`;
- Написать кейс-стади о вашей оптимизации по шаблону `case-study-template.md`.

## Сдача задания
Для сдачи задания нужно форкнуть этот проект, сделать `PR` в него и прислать ссылку для проверки.

В `PR`
- должны быть внесены оптимизации в `task-2.rb`;
- должен быть файл `case-study.md` с описанием проделанной оптимизации;
- в описании должен быть скриншот из `valgrind massif visualizer`, на котором видно, что программа укладывается в бюджет на протяжении всего времени исполнения;
- в описание `PR` добавьте чеклист и отметьте, что из него сделали; для получения максимальной пользы надо отметить всё.

## Checklist
- [ ] Построить и проанализировать отчёт гемом `memory_profiler`
- [ ] Построить и проанализировать отчёт `ruby-prof` в режиме `Flat`;
- [ ] Построить и проанализировать отчёт `ruby-prof` в режиме `Graph`;
- [ ] Построить и проанализировать отчёт `ruby-prof` в режиме `CallStack`;
- [ ] Построить и проанализировать отчёт `ruby-prof` в режиме `CallTree` c визуализацией в `QCachegrind`;
- [ ] Построить и проанализировать текстовый отчёт `stackprof`;
- [ ] Построить и проанализировать отчёт `flamegraph` с помощью `stackprof` и визуализировать его в `speedscope.app`;
- [ ] Построить график потребления памяти в `valgrind massif visualier` и включить скриншот в описание вашего `PR`;
- [ ] Написать тест, на то что программа укладывается в бюджет по памяти

Не нужно включать в `PR` выводы всех этих отчётов, просто используйте каждый хотя бы по разу в вашем `Case-study`.

## Формат шагов case-study
Каждый шаг оптимизации в `case-study` должен содержать четыре составляющих:
- какой отчёт показал главную точку роста
- как вы решили её оптимизировать
- как изменилась метрика
- как изменился отчёт профилировщика

## Заметки
- Не отключайте GC при вычислении метрики
- Отключайте профилировщик при вычислении метрики
- Используйте все описанные инструменты и отчёты хотя бы по разу – научитесь с ними работать!
- Вкладывайтесь в удобство разработки и скорость фидбек-лупа!

